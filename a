BASH_COMPLETION_VERSINFO=(2 11)
+++ BASH_COMPLETION_VERSINFO=(2 11)

if [[ $- == *v* ]]; then
    BASH_COMPLETION_ORIGINAL_V_VALUE="-v"
else
    BASH_COMPLETION_ORIGINAL_V_VALUE="+v"
fi
+++ BASH_COMPLETION_ORIGINAL_V_VALUE="-v"

if [[ ${BASH_COMPLETION_DEBUG-} ]]; then
    set -v
else
    set +v
fi
+++ set +v
+++ _blacklist_glob='@(acroread.sh)'
+++ shopt -s extglob progcomp
+++ complete -u groups slay w sux
+++ complete -A stopped -P "% -S " bg
+++ complete -j -P "% -S " fg jobs disown
+++ complete -v readonly unset
+++ complete -A setopt set
+++ complete -A shopt shopt
+++ complete -A helptopic help
+++ complete -a unalias
+++ complete -c command type which
+++ complete -b builtin
+++ _backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|dpkg*|rpm@(orig|new|save))))'
+++ _sysvdirs
+++ sysvdirs=()
+++ sysvdirs+=(/etc/init.d)
+++ return 0
+++ complete -F _service /etc/init.d/alsa-utils
+++ complete -F _service /etc/init.d/anacron
+++ complete -F _service /etc/init.d/apparmor
+++ complete -F _service /etc/init.d/apport
+++ complete -F _service /etc/init.d/bluetooth
+++ complete -F _service /etc/init.d/console-setup.sh
+++ complete -F _service /etc/init.d/cron
+++ complete -F _service /etc/init.d/cups
+++ complete -F _service /etc/init.d/dbus
+++ complete -F _service /etc/init.d/gdm3
+++ complete -F _service /etc/init.d/grub-common
+++ complete -F _service /etc/init.d/hwclock.sh
+++ complete -F _service /etc/init.d/kerneloops
+++ complete -F _service /etc/init.d/keyboard-setup.sh
+++ complete -F _service /etc/init.d/kmod
+++ complete -F _service /etc/init.d/lttng-sessiond
+++ complete -F _service /etc/init.d/openvpn
+++ complete -F _service /etc/init.d/plymouth
+++ complete -F _service /etc/init.d/plymouth-log
+++ complete -F _service /etc/init.d/procps
+++ complete -F _service /etc/init.d/pulseaudio-enable-autospawn
+++ complete -F _service /etc/init.d/rsync
+++ complete -F _service /etc/init.d/saned
+++ complete -F _service /etc/init.d/speech-dispatcher
+++ complete -F _service /etc/init.d/spice-vdagent
+++ complete -F _service /etc/init.d/sssd
+++ complete -F _service /etc/init.d/sysstat
+++ complete -F _service /etc/init.d/ubuntu-fan
+++ complete -F _service /etc/init.d/ufw
+++ complete -F _service /etc/init.d/unattended-upgrades
+++ complete -F _service /etc/init.d/uuidd
+++ complete -F _service /etc/init.d/whoopsie
+++ complete -F _service /etc/init.d/x11-common
+++ unset svc svcdir sysvdirs
+++ shopt -u hostcomplete
+++ complete -F _user_at_host talk ytalk finger
+++ complete -F _known_hosts traceroute traceroute6 fping fping6 telnet rsh rlogin ftp dig mtr ssh-installkeys showmount
+++ shopt -q cdable_vars
+++ complete -F _cd -o nospace cd pushd
+++ complete -F _command aoss command do else eval exec ltrace nice nohup padsp then time tsocks vsound xargs
+++ complete -F _root_command fakeroot gksu gksudo kdesudo really
+++ complete -F _longopt a2ps awk base64 bash bc bison cat chroot colordiff cp csplit cut date df diff dir du enscript env expand fmt fold gperf grep grub head irb ld ldd less ln ls m4 md5sum mkdir mkfifo mknod mv netstat nl nm objcopy objdump od paste pr ptx readelf rm rmdir sed seq shasum sha1sum sha224sum sha256sum sha384sum sha512sum shar sort split strip sum tac tail tee texindex touch tr uname unexpand uniq units vdir wc who
+++ declare -Ag _xspecs
+++ _install_xspec !*.?(t)bz?(2) bunzip2 bzcat pbunzip2 pbzcat lbunzip2 lbzcat
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(zip|[aegjswx]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|aab|ipa|do[ct][xm]|p[op]t[mx]|xl[st][xm]|pyz|whl|[Ff][Cc][Ss]td) unzip zipinfo
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec *.Z compress znew
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(Z|[gGd]z|t[ag]z) gunzip zcat
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(Z|[gGdz]z|t[ag]z) unpigz
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.Z uncompress
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(tlz|lzma) lzcat lzegrep lzfgrep lzgrep lzless lzmore unlzma
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(?(t)xz|tlz|lzma) unxz xzcat
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.lrz lrunzip
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx) ee
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|svg) qiv
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(gif|jp?(e)g?(2)|j2[ck]|jp[2f]|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|?(e)ps) xv
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z)) gv ggv kghostview
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(dvi|DVI)?(.@(gz|Z|bz2)) xdvi kdvi
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.dvi dvips dviselect dvitype dvipdf advi dvipdfm dvipdfmx
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.[pf]df acroread gpdf
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(pdf|fdf)?(.@(gz|GZ|bz2|BZ2|Z)) xpdf
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(?(e)ps|pdf) kpdf
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(okular|@(?(e|x)ps|?(E|X)PS|[pf]df|[PF]DF|dvi|DVI|cb[rz]|CB[RZ]|djv?(u)|DJV?(U)|dvi|DVI|gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX|epub|EPUB|odt|ODT|fb?(2)|FB?(2)|mobi|MOBI|g3|G3|chm|CHM)?(.?(gz|GZ|bz2|BZ2|xz|XZ))) okular
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.pdf epdfview pdfunite
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(cb[rz7t]|djv?(u)|?(e)ps|pdf) zathura
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(?(e)ps|pdf) ps2pdf ps2pdf12 ps2pdf13 ps2pdf14 ps2pdfwr
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.texi* makeinfo texi2html
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(?(la)tex|texi|dtx|ins|ltx|dbj) tex latex slitex jadetex pdfjadetex pdftex pdflatex texi2dvi xetex xelatex luatex lualatex
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.mp3 mpg123 mpg321 madplay
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part)) xine aaxine fbxine
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part)) kaffeine dragon totem
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(avi|asf|wmv) aviplay
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(rm?(j)|ra?(m)|smi?(l)) realplay
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(mpg|mpeg|avi|mov|qt) xanim
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(og[ag]|m3u|flac|spx) ogg123
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(mp3|og[ag]|pls|m3u) gqmpeg freeamp
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.fig xfig
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(mid?(i)|cmf) playmidi
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(mid?(i)|rmi|rcp|[gr]36|g18|mod|xm|it|x3m|s[3t]m|kar) timidity
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|oct|okt?(a)|p[st]m|s[3t]m|ult|umx|wav|xm) modplugplay modplug123
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec *.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class) vi vim gvim rvim view rview rgvim rgview gview emacs xemacs sxemacs kate kwrite
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(zip|z|gz|tgz) bzme
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(?([xX]|[sS])[hH][tT][mM]?([lL])) netscape mozilla lynx galeon dillo elinks amaya epiphany
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm|pdf) oowriter lowriter
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp) ooimpress loimpress
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots) oocalc localc
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(sxd|std|sda|sdd|?(f)odg|otg) oodraw lodraw
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(sxm|smf|mml|odf) oomath lomath
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.odb oobase lobase
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.[rs]pm rpm2cpio
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.aux bibtex
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.po poedit gtranslator kbabel lokalize
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@([Pp][Rr][Gg]|[Cc][Ll][Pp]) harbour gharbour hbpp
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.[Hh][Rr][Bb] hbrun
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.ly lilypond ly2dvi
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(dif?(f)|?(d)patch)?(.@([gx]z|bz2|lzma)) cdiff
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !@(*.@(ks|jks|jceks|p12|pfx|bks|ubr|gkr|cer|crt|cert|p7b|pkipath|pem|p10|csr|crl)|cacerts) portecle
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _install_xspec !*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape) kid3 kid3-qt
+++ local cmd
+++ shift
+++ _xspecs[$cmd]=$xspec
+++ _xspecs[$cmd]=$xspec
+++ unset -f _install_xspec
+++ complete -F _minimal 
+++ complete -D -F _completion_loader
+++ compat_dir=${BASH_COMPLETION_COMPAT_DIR:-/etc/bash_completion.d}
+++ . /etc/bash_completion.d/git-prompt
++++ unset compat_dir i _blacklist_glob
++++ user_completion=${BASH_COMPLETION_USER_FILE:-~/.bash_completion}
++++ unset user_completion
++++ unset -f have
++++ unset have
++++ set -v
unset BASH_COMPLETION_ORIGINAL_V_VALUE
++++ unset BASH_COMPLETION_ORIGINAL_V_VALUE

# ex: filetype=sh
# In git versions < 1.7.12, this shell library was part of the
# git completion script.
#
# Some users rely on the __git_ps1 function becoming available
# when bash-completion is loaded.  Continue to load this library
# at bash-completion startup for now, to ease the transition to a
# world order where the prompt function is requested separately.
#
if [[ -e /usr/lib/git-core/git-sh-prompt ]]; then
	. /usr/lib/git-core/git-sh-prompt
fi
++++ . /usr/lib/git-core/git-sh-prompt
# bash/zsh git prompt support
#
# Copyright (C) 2006,2007 Shawn O. Pearce <spearce@spearce.org>
# Distributed under the GNU General Public License, version 2.0.
#
# This script allows you to see repository status in your prompt.
#
# To enable:
#
#    1) Copy this file to somewhere (e.g. ~/.git-prompt.sh).
#    2) Add the following line to your .bashrc/.zshrc:
#        source ~/.git-prompt.sh
#    3a) Change your PS1 to call __git_ps1 as
#        command-substitution:
#        Bash: PS1='[\u@\h \W$(__git_ps1 " (%s)")]\$ '
#        ZSH:  setopt PROMPT_SUBST ; PS1='[%n@%m %c$(__git_ps1 " (%s)")]\$ '
#        the optional argument will be used as format string.
#    3b) Alternatively, for a slightly faster prompt, __git_ps1 can
#        be used for PROMPT_COMMAND in Bash or for precmd() in Zsh
#        with two parameters, <pre> and <post>, which are strings
#        you would put in $PS1 before and after the status string
#        generated by the git-prompt machinery.  e.g.
#        Bash: PROMPT_COMMAND='__git_ps1 "\u@\h:\w" "\\\$ "'
#          will show username, at-sign, host, colon, cwd, then
#          various status string, followed by dollar and SP, as
#          your prompt.
#        ZSH:  precmd () { __git_ps1 "%n" ":%~$ " "|%s" }
#          will show username, pipe, then various status string,
#          followed by colon, cwd, dollar and SP, as your prompt.
#        Optionally, you can supply a third argument with a printf
#        format string to finetune the output of the branch status
#
# The repository status will be displayed only if you are currently in a
# git repository. The %s token is the placeholder for the shown status.
#
# The prompt status always includes the current branch name.
#
# In addition, if you set GIT_PS1_SHOWDIRTYSTATE to a nonempty value,
# unstaged (*) and staged (+) changes will be shown next to the branch
# name.  You can configure this per-repository with the
# bash.showDirtyState variable, which defaults to true once
# GIT_PS1_SHOWDIRTYSTATE is enabled.
#
# You can also see if currently something is stashed, by setting
# GIT_PS1_SHOWSTASHSTATE to a nonempty value. If something is stashed,
# then a '$' will be shown next to the branch name.
#
# If you would like to see if there're untracked files, then you can set
# GIT_PS1_SHOWUNTRACKEDFILES to a nonempty value. If there're untracked
# files, then a '%' will be shown next to the branch name.  You can
# configure this per-repository with the bash.showUntrackedFiles
# variable, which defaults to true once GIT_PS1_SHOWUNTRACKEDFILES is
# enabled.
#
# If you would like to see the difference between HEAD and its upstream,
# set GIT_PS1_SHOWUPSTREAM="auto".  A "<" indicates you are behind, ">"
# indicates you are ahead, "<>" indicates you have diverged and "="
# indicates that there is no difference. You can further control
# behaviour by setting GIT_PS1_SHOWUPSTREAM to a space-separated list
# of values:
#
#     verbose       show number of commits ahead/behind (+/-) upstream
#     name          if verbose, then also show the upstream abbrev name
#     legacy        don't use the '--count' option available in recent
#                   versions of git-rev-list
#     git           always compare HEAD to @{upstream}
#     svn           always compare HEAD to your SVN upstream
#
# By default, __git_ps1 will compare HEAD to your SVN upstream if it can
# find one, or @{upstream} otherwise.  Once you have set
# GIT_PS1_SHOWUPSTREAM, you can override it on a per-repository basis by
# setting the bash.showUpstream config variable.
#
# You can change the separator between the branch name and the above
# state symbols by setting GIT_PS1_STATESEPARATOR. The default separator
# is SP.
#
# When there is an in-progress operation such as a merge, rebase,
# revert, cherry-pick, or bisect, the prompt will include information
# related to the operation, often in the form "|<OPERATION-NAME>".
#
# When the repository has a sparse-checkout, a notification of the form
# "|SPARSE" will be included in the prompt.  This can be shortened to a
# single '?' character by setting GIT_PS1_COMPRESSSPARSESTATE, or omitted
# by setting GIT_PS1_OMITSPARSESTATE.
#
# If you would like to see a notification on the prompt when there are
# unresolved conflicts, set GIT_PS1_SHOWCONFLICTSTATE to "yes". The
# prompt will include "|CONFLICT".
#
# If you would like to see more information about the identity of
# commits checked out as a detached HEAD, set GIT_PS1_DESCRIBE_STYLE
# to one of these values:
#
#     contains      relative to newer annotated tag (v1.6.3.2~35)
#     branch        relative to newer tag or branch (master~4)
#     describe      relative to older annotated tag (v1.6.3.1-13-gdd42c2f)
#     tag           relative to any older tag (v1.6.3.1-13-gdd42c2f)
#     default       exactly matching tag
#
# If you would like a colored hint about the current dirty state, set
# GIT_PS1_SHOWCOLORHINTS to a nonempty value. The colors are based on
# the colored output of "git status -sb".
#
# If you would like __git_ps1 to do nothing in the case when the current
# directory is set up to be ignored by git, then set
# GIT_PS1_HIDE_IF_PWD_IGNORED to a nonempty value. Override this on the
# repository level by setting bash.hideIfPwdIgnored to "false".

# check whether printf supports -v
__git_printf_supports_v=
+++++ __git_printf_supports_v=
printf -v __git_printf_supports_v -- '%s' yes >/dev/null 2>&1
+++++ printf -v __git_printf_supports_v -- %s yes

# stores the divergence from upstream in $p
# used by GIT_PS1_SHOWUPSTREAM
__git_ps1_show_upstream ()
{
	local key value
	local svn_remote svn_url_pattern count n
	local upstream_type=git legacy="" verbose="" name=""

	svn_remote=()
	# get some config options from git-config
	local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')"
	while read -r key value; do
		case "$key" in
		bash.showupstream)
			GIT_PS1_SHOWUPSTREAM="$value"
			if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
				p=""
				return
			fi
			;;
		svn-remote.*.url)
			svn_remote[$((${#svn_remote[@]} + 1))]="$value"
			svn_url_pattern="$svn_url_pattern\\|$value"
			upstream_type=svn+git # default upstream type is SVN if available, else git
			;;
		esac
	done <<< "$output"

	# parse configuration values
	local option
	for option in ${GIT_PS1_SHOWUPSTREAM}; do
		case "$option" in
		git|svn) upstream_type="$option" ;;
		verbose) verbose=1 ;;
		legacy)  legacy=1  ;;
		name)    name=1 ;;
		esac
	done

	# Find our upstream type
	case "$upstream_type" in
	git)    upstream_type="@{upstream}" ;;
	svn*)
		# get the upstream from the "git-svn-id: ..." in a commit message
		# (git-svn uses essentially the same procedure internally)
		local -a svn_upstream
		svn_upstream=($(git log --first-parent -1 \
					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null))
		if [[ 0 -ne ${#svn_upstream[@]} ]]; then
			svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]}
			svn_upstream=${svn_upstream%@*}
			local n_stop="${#svn_remote[@]}"
			for ((n=1; n <= n_stop; n++)); do
				svn_upstream=${svn_upstream#${svn_remote[$n]}}
			done

			if [[ -z "$svn_upstream" ]]; then
				# default branch name for checkouts with no layout:
				upstream_type=${GIT_SVN_ID:-git-svn}
			else
				upstream_type=${svn_upstream#/}
			fi
		elif [[ "svn+git" = "$upstream_type" ]]; then
			upstream_type="@{upstream}"
		fi
		;;
	esac

	# Find how many commits we are ahead/behind our upstream
	if [[ -z "$legacy" ]]; then
		count="$(git rev-list --count --left-right \
				"$upstream_type"...HEAD 2>/dev/null)"
	else
		# produce equivalent output to --count for older versions of git
		local commits
		if commits="$(git rev-list --left-right "$upstream_type"...HEAD 2>/dev/null)"
		then
			local commit behind=0 ahead=0
			for commit in $commits
			do
sush: Unexpected token: 			do

				case "$commit" in
				"<"*) ((behind++)) ;;
				*)    ((ahead++))  ;;
				esac
			done
sush: Unexpected token: done

			count="$behind	$ahead"
		else
sush: Unexpected token: else

sush: Unexpected token: ()
{
	local
			count=""
+++++ count=""
		fi
sush: Unexpected token: fi

	fi
sush: Unexpected token: fi


	# calculate the result
	if [[ -z "$verbose" ]]; then
		case "$count" in
		"") # no upstream
			p="" ;;
		"0	0") # equal to upstream
			p="=" ;;
		"0	"*) # ahead of upstream
			p=">" ;;
		*"	0") # behind upstream
			p="<" ;;
		*)	    # diverged from upstream
			p="<>" ;;
		esac
	else # verbose, set upstream instead of p
		case "$count" in
		"") # no upstream
			upstream="" ;;
		"0	0") # equal to upstream
			upstream="|u=" ;;
		"0	"*) # ahead of upstream
			upstream="|u+${count#0	}" ;;
		*"	0") # behind upstream
			upstream="|u-${count%	0}" ;;
		*)	    # diverged from upstream
			upstream="|u+${count#*	}-${count%	*}" ;;
		esac
		if [[ -n "$count" && -n "$name" ]]; then
			__git_ps1_upstream_name=$(git rev-parse \
				--abbrev-ref "$upstream_type" 2>/dev/null)
			if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then
				upstream="$upstream \${__git_ps1_upstream_name}"
			else
				upstream="$upstream ${__git_ps1_upstream_name}"
				# not needed anymore; keep user's
				# environment clean
				unset __git_ps1_upstream_name
			fi
		fi
	fi
+++++ case "$count" in
+++++ p=""

}
sush: Unexpected token: }


# Helper function that is meant to be called from __git_ps1.  It
# injects color codes into the appropriate gitstring variables used
# to build a gitstring. Colored variables are responsible for clearing
# their own color.
__git_ps1_colorize_gitstring ()
{
	if [[ -n ${ZSH_VERSION-} ]]; then
		local c_red='%F{red}'
		local c_green='%F{green}'
		local c_lblue='%F{blue}'
		local c_clear='%f'
	else
		# Using \001 and \002 around colors is necessary to prevent
		# issues with command line editing/browsing/completion!
		local c_red=$'\001\e[31m\002'
		local c_green=$'\001\e[32m\002'
		local c_lblue=$'\001\e[1;34m\002'
		local c_clear=$'\001\e[0m\002'
	fi
	local bad_color=$c_red
	local ok_color=$c_green
	local flags_color="$c_lblue"

	local branch_color=""
	if [ $detached = no ]; then
		branch_color="$ok_color"
	else
		branch_color="$bad_color"
	fi
	if [ -n "$c" ]; then
		c="$branch_color$c$c_clear"
	fi
	b="$branch_color$b$c_clear"

	if [ -n "$w" ]; then
		w="$bad_color$w$c_clear"
	fi
	if [ -n "$i" ]; then
		i="$ok_color$i$c_clear"
	fi
	if [ -n "$s" ]; then
		s="$flags_color$s$c_clear"
	fi
	if [ -n "$u" ]; then
		u="$bad_color$u$c_clear"
	fi
}

# Helper function to read the first line of a file into a variable.
# __git_eread requires 2 arguments, the file path and the name of the
# variable, in that order.
__git_eread ()
{
	test -r "$1" && IFS=$'\r\n' read -r "$2" <"$1"
}

# see if a cherry-pick or revert is in progress, if the user has committed a
# conflict resolution with 'git commit' in the middle of a sequence of picks or
# reverts then CHERRY_PICK_HEAD/REVERT_HEAD will not exist so we have to read
# the todo file.
__git_sequencer_status ()
{
	local todo
	if test -f "$g/CHERRY_PICK_HEAD"
	then
		r="|CHERRY-PICKING"
		return 0;
	elif test -f "$g/REVERT_HEAD"
	then
		r="|REVERTING"
		return 0;
	elif __git_eread "$g/sequencer/todo" todo
	then
		case "$todo" in
		p[\ \	]|pick[\ \	]*)
			r="|CHERRY-PICKING"
			return 0
		;;
		revert[\ \	]*)
			r="|REVERTING"
			return 0
		;;
		esac
	fi
	return 1
}

# __git_ps1 accepts 0 or 1 arguments (i.e., format string)
# when called from PS1 using command substitution
# in this mode it prints text to add to bash PS1 prompt (includes branch name)
#
# __git_ps1 requires 2 or 3 arguments when called from PROMPT_COMMAND (pc)
# in that case it _sets_ PS1. The arguments are parts of a PS1 string.
# when two arguments are given, the first is prepended and the second appended
# to the state string when assigned to PS1.
# The optional third parameter will be used as printf format string to further
# customize the output of the git-status string.
# In this mode you can request colored hints using GIT_PS1_SHOWCOLORHINTS=true
__git_ps1 ()
{
	# preserve exit status
	local exit=$?
	local pcmode=no
	local detached=no
	local ps1pc_start='\u@\h:\w '
	local ps1pc_end='\$ '
	local printf_format=' (%s)'

	case "$#" in
		2|3)	pcmode=yes
			ps1pc_start="$1"
			ps1pc_end="$2"
			printf_format="${3:-$printf_format}"
			# set PS1 to a plain prompt so that we can
			# simply return early if the prompt should not
			# be decorated
			PS1="$ps1pc_start$ps1pc_end"
		;;
		0|1)	printf_format="${1:-$printf_format}"
		;;
		*)	return $exit
		;;
	esac

	# ps1_expanded:  This variable is set to 'yes' if the shell
	# subjects the value of PS1 to parameter expansion:
	#
	#   * bash does unless the promptvars option is disabled
	#   * zsh does not unless the PROMPT_SUBST option is set
	#   * POSIX shells always do
	#
	# If the shell would expand the contents of PS1 when drawing
	# the prompt, a raw ref name must not be included in PS1.
	# This protects the user from arbitrary code execution via
	# specially crafted ref names.  For example, a ref named
	# 'refs/heads/$(IFS=_;cmd=sudo_rm_-rf_/;$cmd)' might cause the
	# shell to execute 'sudo rm -rf /' when the prompt is drawn.
	#
	# Instead, the ref name should be placed in a separate global
	# variable (in the __git_ps1_* namespace to avoid colliding
	# with the user's environment) and that variable should be
	# referenced from PS1.  For example:
	#
	#     __git_ps1_foo=$(do_something_to_get_ref_name)
	#     PS1="...stuff...\${__git_ps1_foo}...stuff..."
	#
	# If the shell does not expand the contents of PS1, the raw
	# ref name must be included in PS1.
	#
	# The value of this variable is only relevant when in pcmode.
	#
	# Assume that the shell follows the POSIX specification and
	# expands PS1 unless determined otherwise.  (This is more
	# likely to be correct if the user has a non-bash, non-zsh
	# shell and safer than the alternative if the assumption is
	# incorrect.)
	#
	local ps1_expanded=yes
	[ -z "${ZSH_VERSION-}" ] || [[ -o PROMPT_SUBST ]] || ps1_expanded=no
	[ -z "${BASH_VERSION-}" ] || shopt -q promptvars || ps1_expanded=no

	local repo_info rev_parse_exit_code
	repo_info="$(git rev-parse --git-dir --is-inside-git-dir \
		--is-bare-repository --is-inside-work-tree \
		--short HEAD 2>/dev/null)"
	rev_parse_exit_code="$?"

	if [ -z "$repo_info" ]; then
		return $exit
	fi

	local short_sha=""
	if [ "$rev_parse_exit_code" = "0" ]; then
		short_sha="${repo_info##*$'\n'}"
		repo_info="${repo_info%$'\n'*}"
	fi
	local inside_worktree="${repo_info##*$'\n'}"
	repo_info="${repo_info%$'\n'*}"
	local bare_repo="${repo_info##*$'\n'}"
	repo_info="${repo_info%$'\n'*}"
	local inside_gitdir="${repo_info##*$'\n'}"
	local g="${repo_info%$'\n'*}"

	if [ "true" = "$inside_worktree" ] &&
	   [ -n "${GIT_PS1_HIDE_IF_PWD_IGNORED-}" ] &&
	   [ "$(git config --bool bash.hideIfPwdIgnored)" != "false" ] &&
	   git check-ignore -q .
	then
		return $exit
	fi

	local sparse=""
	if [ -z "${GIT_PS1_COMPRESSSPARSESTATE-}" ] &&
	   [ -z "${GIT_PS1_OMITSPARSESTATE-}" ] &&
	   [ "$(git config --bool core.sparseCheckout)" = "true" ]; then
		sparse="|SPARSE"
	fi

	local r=""
	local b=""
	local step=""
	local total=""
	if [ -d "$g/rebase-merge" ]; then
		__git_eread "$g/rebase-merge/head-name" b
		__git_eread "$g/rebase-merge/msgnum" step
		__git_eread "$g/rebase-merge/end" total
		r="|REBASE"
	else
		if [ -d "$g/rebase-apply" ]; then
			__git_eread "$g/rebase-apply/next" step
			__git_eread "$g/rebase-apply/last" total
			if [ -f "$g/rebase-apply/rebasing" ]; then
				__git_eread "$g/rebase-apply/head-name" b
				r="|REBASE"
			elif [ -f "$g/rebase-apply/applying" ]; then
				r="|AM"
			else
				r="|AM/REBASE"
			fi
		elif [ -f "$g/MERGE_HEAD" ]; then
			r="|MERGING"
		elif __git_sequencer_status; then
			:
		elif [ -f "$g/BISECT_LOG" ]; then
			r="|BISECTING"
		fi

		if [ -n "$b" ]; then
			:
		elif [ -h "$g/HEAD" ]; then
			# symlink symbolic ref
			b="$(git symbolic-ref HEAD 2>/dev/null)"
		else
			local head=""
			if ! __git_eread "$g/HEAD" head; then
				return $exit
			fi
			# is it a symbolic ref?
			b="${head#ref: }"
			if [ "$head" = "$b" ]; then
				detached=yes
				b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
sush: Unexpected token: (contains)

					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(tag)
					git describe --tags HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" ||

				b="$short_sha..."
				b="($b)"
			fi
		fi
	fi

	if [ -n "$step" ] && [ -n "$total" ]; then
		r="$r $step/$total"
	fi

	local conflict="" # state indicator for unresolved conflicts
	if [[ "${GIT_PS1_SHOWCONFLICTSTATE}" == "yes" ]] &&
	   [[ $(git ls-files --unmerged 2>/dev/null) ]]; then
		conflict="|CONFLICT"
	fi

	local w=""
	local i=""
	local s=""
	local u=""
	local h=""
	local c=""
	local p="" # short version of upstream state indicator
	local upstream="" # verbose version of upstream state indicator

	if [ "true" = "$inside_gitdir" ]; then
		if [ "true" = "$bare_repo" ]; then
			c="BARE:"
		else
			b="GIT_DIR!"
		fi
	elif [ "true" = "$inside_worktree" ]; then
		if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] &&
		   [ "$(git config --bool bash.showDirtyState)" != "false" ]
		then
			git diff --no-ext-diff --quiet || w="*"
			git diff --no-ext-diff --cached --quiet || i="+"
			if [ -z "$short_sha" ] && [ -z "$i" ]; then
				i="#"
			fi
		fi
		if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] &&
		   git rev-parse --verify --quiet refs/stash >/dev/null
		then
			s="$"
		fi

		if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] &&
		   [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] &&
		   git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- ':/*' >/dev/null 2>/dev/null
		then
			u="%${ZSH_VERSION+%}"
		fi

		if [ -n "${GIT_PS1_COMPRESSSPARSESTATE-}" ] &&
		   [ "$(git config --bool core.sparseCheckout)" = "true" ]; then
			h="?"
		fi

		if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
			__git_ps1_show_upstream
		fi
	fi

	local z="${GIT_PS1_STATESEPARATOR-" "}"

	b=${b##refs/heads/}
	if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then
		__git_ps1_branch_name=$b
		b="\${__git_ps1_branch_name}"
	fi

	if [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then
		__git_ps1_colorize_gitstring
	fi

	local f="$h$w$i$s$u$p"
	local gitstring="$c$b${f:+$z$f}${sparse}$r${upstream}${conflict}"

	if [ $pcmode = yes ]; then
		if [ "${__git_printf_supports_v-}" != yes ]; then
			gitstring=$(printf -- "$printf_format" "$gitstring")
		else
			printf -v gitstring -- "$printf_format" "$gitstring"
		fi
		PS1="$ps1pc_start$gitstring$ps1pc_end"
	else
		printf -- "$printf_format" "$gitstring"
	fi

	return $exit
}
+++ . /etc/bash_completion.d/global-python-argcomplete
# Enable python-argcomplete global completions
# This checks for a PYTHON_ARGCOMPLETE_OK in the first 1024 bytes of any
# executable, and if found will attempt to use argcomplete completions.

if [[ -e /usr/lib/python3/dist-packages/argcomplete/bash_completion.d/_python-argcomplete ]]; then
	. /usr/lib/python3/dist-packages/argcomplete/bash_completion.d/_python-argcomplete
fi
++++ . /usr/lib/python3/dist-packages/argcomplete/bash_completion.d/_python-argcomplete
#compdef -P *

# Copyright 2012-2023, Andrey Kislyuk and argcomplete contributors.
# Licensed under the Apache License. See https://github.com/kislyuk/argcomplete for more info.

# Note: both the leading underscore in the name of this file and the first line (compdef) are required by zsh

# Copy of __expand_tilde_by_ref from bash-completion
# ZSH implementation added
__python_argcomplete_expand_tilde_by_ref () {
    if [ -n "${ZSH_VERSION-}" ]; then
        if [ "${(P)1[1]}" = "~" ]; then
            eval $1="${(P)1/#\~/$HOME}";
        fi
    else
        if [ "${!1:0:1}" = "~" ]; then
            if [ "${!1}" != "${!1//\/}" ]; then
                eval $1="${!1/%\/*}"/'${!1#*/}';
            else
                eval $1="${!1}";
            fi;
        fi
    fi
}

# Run something, muting output or redirecting it to the debug stream
# depending on the value of _ARC_DEBUG.
# If ARGCOMPLETE_USE_TEMPFILES is set, use tempfiles for IPC.
__python_argcomplete_run() {
    if [[ -z "${ARGCOMPLETE_USE_TEMPFILES-}" ]]; then
        __python_argcomplete_run_inner "$@"
        return
    fi
    local tmpfile="$(mktemp)"
    _ARGCOMPLETE_STDOUT_FILENAME="$tmpfile" __python_argcomplete_run_inner "$@"
    local code=$?
    cat "$tmpfile"
    rm "$tmpfile"
    return $code
}

__python_argcomplete_run_inner() {
    if [[ -z "${_ARC_DEBUG-}" ]]; then
        "$@" 8>&1 9>&2 1>/dev/null 2>&1
    else
        "$@" 8>&1 9>&2 1>&9 2>&1
    fi
}

__python_argcomplete_upshift_bash_rematch() {
    if [[ -z "${ZSH_VERSION-}" ]]; then
        _BASH_REMATCH=( "" "${BASH_REMATCH[@]}" )
    else
        _BASH_REMATCH=( "${BASH_REMATCH[@]}" )
    fi
}

# This function scans the beginning of an executable file provided as the first
# argument ($1) for certain indicators, specified by the second argument ($2),
# or the "target". There are three possible targets: "interpreter",
# "magic_string", and "easy_install". If the target is "interpreter", the
# function matches the interpreter line, alongside any optional interpreter
# arguments. If the target is "magic_string", a match is attempted for the
# "PYTHON_ARGCOMPLETE_OK" magic string, indicating that the file should be run
# to get completions. If the target is "easy_install", the function matches either
# "PBR Generated" or any of the "EASY-INSTALL" scripts (either SCRIPT,
# ENTRY-SCRIPT, or DEV-SCRIPT). In all cases, only the first kilobyte of
# the file is searched. The regex matches are returned in BASH_REMATCH,
# indexed starting at 1, regardless of the shell in use.
__python_argcomplete_scan_head() {
    local file="$1"
    local target="$2"

    if [[ -n "${ZSH_VERSION-}" ]]; then
        read -r -k 1024 -u 0 < "$file";
    else
        read -r -N 1024 < "$file"
    fi

    # Since ZSH does not support a -n option, we
    # trim all characters after the first line in both shells
    if [[ "$target" = "interpreter" ]]; then
        read -r <<< "$REPLY"
    fi

    local regex

    case "$target" in
            magic_string) regex='PYTHON_ARGCOMPLETE_OK' ;;
            easy_install) regex="(PBR Generated)|(EASY-INSTALL-(SCRIPT|ENTRY-SCRIPT|DEV-SCRIPT))" ;;
            asdf) regex="asdf exec " ;;
            interpreter) regex='^#!(.*)$' ;;
    esac

    local ret=""
    if [[ "$REPLY" =~ $regex ]]; then
        ret=1
    fi

    __python_argcomplete_upshift_bash_rematch

    [[ -n $ret ]]
}

__python_argcomplete_scan_head_noerr() {
    __python_argcomplete_scan_head "$@" 2>/dev/null
}

__python_argcomplete_which() {
    if [[ -n "${ZSH_VERSION-}" ]]; then
        whence -p "$@"
    else
        type -P "$@"
    fi
}

_python_argcomplete_global() {

    if [[ -n "${ZSH_VERSION-}" ]]; then
        # Store result of a regex match in the
        # BASH_REMATCH variable rather than MATCH
        setopt local_options BASH_REMATCH
    fi

    # 1-based version of BASH_REMATCH. Modifying BASH_REMATCH
    # directly causes older versions of Bash to exit
    local _BASH_REMATCH="";

    local executable=""

    # req_argv contains the arguments to the completion
    # indexed from 1 (regardless of the shell.) In Bash,
    # the zeroth index is empty
    local req_argv=()

    if [[ -z "${ZSH_VERSION-}" ]]; then
        executable=$1
        req_argv=( "" "${COMP_WORDS[@]:1}" )
        __python_argcomplete_expand_tilde_by_ref executable
    else
        if [[ "$service" != "-default-" ]]; then
            # TODO: this may not be sufficient - see https://zsh.sourceforge.io/Doc/Release/Completion-System.html
            # May need to call _complete with avoid-completer=_python-argcomplete or something like that
            _default
            return
        fi
        executable="${words[1]}"
        req_argv=( "${words[@]:1}" )
    fi

    local ARGCOMPLETE=0
    if [[ "$executable" == python* ]] || [[ "$executable" == pypy* ]]; then
        if [[ "${req_argv[1]}" == -m ]]; then
            if __python_argcomplete_run "$executable" -m argcomplete._check_module "${req_argv[2]}"; then
                ARGCOMPLETE=3
            else
                return
            fi
        fi
        if [[ $ARGCOMPLETE == 0 ]]; then
            local potential_path="${req_argv[1]}"
            __python_argcomplete_expand_tilde_by_ref potential_path
            if [[ -f "$potential_path" ]] && __python_argcomplete_scan_head_noerr "$potential_path" magic_string; then
                req_argv[1]="$potential_path" # not expanded in __python_argcomplete_run
                ARGCOMPLETE=2
            else
                return
            fi
        fi
    elif __python_argcomplete_which "$executable" >/dev/null 2>&1; then
        local SCRIPT_NAME=$(__python_argcomplete_which "$executable")
        __python_argcomplete_scan_head_noerr "$SCRIPT_NAME" interpreter
        if (__python_argcomplete_which pyenv && [[ "$SCRIPT_NAME" = $(pyenv root)/shims/* ]]) >/dev/null 2>&1; then
            local SCRIPT_NAME=$(pyenv which "$executable")
        fi
        if (__python_argcomplete_which asdf && __python_argcomplete_scan_head_noerr "$SCRIPT_NAME" asdf) >/dev/null 2>&1; then
            local SCRIPT_NAME=$(asdf which "$executable")
        fi
        if __python_argcomplete_scan_head_noerr "$SCRIPT_NAME" magic_string; then
            ARGCOMPLETE=1
        elif __python_argcomplete_scan_head_noerr "$SCRIPT_NAME" interpreter; then
            __python_argcomplete_upshift_bash_rematch
            local interpreter="${_BASH_REMATCH[2]}"

            if [[ -n "${ZSH_VERSION-}" ]]; then
                interpreter=($=interpreter)
            else
                interpreter=($interpreter)
            fi

            if (__python_argcomplete_scan_head_noerr "$SCRIPT_NAME" easy_install \
                && "${interpreter[@]}" "$(__python_argcomplete_which python-argcomplete-check-easy-install-script)" "$SCRIPT_NAME") >/dev/null 2>&1; then
                ARGCOMPLETE=1
            elif __python_argcomplete_run "${interpreter[@]}" -m argcomplete._check_console_script "$SCRIPT_NAME"; then
                ARGCOMPLETE=1
            fi
        fi
    fi

    if [[ $ARGCOMPLETE != 0 ]]; then
        local IFS=$'\013'
        if [[ -n "${ZSH_VERSION-}" ]]; then
            local completions
            completions=($(IFS="$IFS" \
                COMP_LINE="$BUFFER" \
                COMP_POINT="$CURSOR" \
                _ARGCOMPLETE=$ARGCOMPLETE \
                _ARGCOMPLETE_SHELL="zsh" \
                _ARGCOMPLETE_SUPPRESS_SPACE=1 \
                __python_argcomplete_run "$executable" "${(@)req_argv[1, ${ARGCOMPLETE}-1]}"))
            _describe "$executable" completions
        else
            COMPREPLY=($(IFS="$IFS" \
                COMP_LINE="$COMP_LINE" \
                COMP_POINT="$COMP_POINT" \
                COMP_TYPE="$COMP_TYPE" \
                _ARGCOMPLETE_COMP_WORDBREAKS="$COMP_WORDBREAKS" \
                _ARGCOMPLETE=$ARGCOMPLETE \
                _ARGCOMPLETE_SHELL="bash" \
                _ARGCOMPLETE_SUPPRESS_SPACE=1 \
                __python_argcomplete_run "$executable" "${req_argv[@]:1:${ARGCOMPLETE}-1}"))
            if [[ $? != 0 ]]; then
                unset COMPREPLY
            elif [[ "${COMPREPLY-}" =~ [=/:]$ ]]; then
                compopt -o nospace
            fi
        fi
    elif [[ -n "${ZSH_VERSION-}" ]]; then
        _default
    else
        type -t _completion_loader | grep -q 'function' && _completion_loader "$@"
    fi
}
if [[ -z "${ZSH_VERSION-}" ]]; then
    complete -o default -o bashdefault -D -F _python_argcomplete_global
else
    compdef _python_argcomplete_global -P '*'
fi
+++++ complete -o default -o bashdefault -D -F _python_argcomplete_global
sush: complete -o: still unsupported
Rusty Bash (a.k.a. Sushi shell), version 0.10.1 - release
vi a
+ vi a
grep 'produce equivalent output' /usr/share/ -R
+ grep 'produce equivalent output' /usr/share/ -R
Pid: Pid(40334), Signal: SIGINT





grep 'produce equivalent output' /usr/share/bash-completion 
+ grep 'produce equivalent output' /usr/share/bash-completion
grep: /usr/share/bash-completion: ディレクトリです
grep 'produce equivalent output' /usr/share/bash-completion -R 
+ grep 'produce equivalent output' /usr/share/bash-completion -R
grep: /usr/share/bash-completion/completions/node: そのようなファイルやディレクトリはありません
grep 'produce equivalent output' /usr/share/ -R
+ grep 'produce equivalent output' /usr/share/ -R
grep: /usr/share/nodejs/npm/man/man1/cpp-13.1: そのようなファイルやディレクトリはありません
grep: /usr/share/nodejs/npm/man/man1/gfortran-13.1: そのようなファイルやディレクトリはありません
grep: /usr/share/nodejs/npm/man/man1/cpp.1.gz: そのようなファイルやディレクトリはありません
grep: /usr/share/nodejs/npm/man/man1/gfortran.1.gz: そのようなファイルやディレクトリはありません
grep: /usr/share/npm/man/man1/cpp-13.1: そのようなファイルやディレクトリはありません
grep: /usr/share/npm/man/man1/gfortran-13.1: そのようなファイルやディレクトリはありません
grep: /usr/share/npm/man/man1/cpp.1.gz: そのようなファイルやディレクトリはありません
grep: /usr/share/npm/man/man1/gfortran.1.gz: そのようなファイルやディレクトリはありません
grep: /usr/share/node_modules/npm/man/man1/cpp-13.1: そのようなファイルやディレクトリはありません
grep: /usr/share/node_modules/npm/man/man1/gfortran-13.1: そのようなファイルやディレクトリはありません
grep: /usr/share/node_modules/npm/man/man1/cpp.1.gz: そのようなファイルやディレクトリはありません
grep: /usr/share/node_modules/npm/man/man1/gfortran.1.gz: そのようなファイルやディレクトリはありません
grep: /usr/share/man/man1/cpp-13.1: そのようなファイルやディレクトリはありません
grep: /usr/share/man/man1/gfortran-13.1: そのようなファイルやディレクトリはありません
grep: /usr/share/man/man1/cpp.1.gz: そのようなファイルやディレクトリはありません
grep: /usr/share/man/man1/gfortran.1.gz: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/kk/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/ga/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/da/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/zh_TW/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/lt/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/pl/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/nb/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/eo/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/ro/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/eu/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/zh_CN/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/ka/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/be/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/ta/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/el/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/nl/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/ja/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/sl/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/uk/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/sv/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/af/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/ru/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/id/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/fi/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/bg/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/tr/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/vi/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/pt/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/sk/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/fr/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/it/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/es/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/hr/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/de/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/ms/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/et/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/lg/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/gl/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/ca/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/sr/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/pt_BR/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/ia/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/cs/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/hu/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/locale/ko/LC_TIME/coreutils.mo: そのようなファイルやディレクトリはありません
grep: /usr/share/bash-completion/completions/node: そのようなファイルやディレクトリはありません
grep: /usr/share/gnome-control-center/icons/hicolor/48x48/devices/audio-speaker-mono-testing.svg: そのようなファイルやディレクトリはありません
grep: /usr/share/gnome-control-center/icons/hicolor/48x48/devices/audio-speaker-mono.svg: そのようなファイルやディレクトリはありません
Pid: Pid(40354), Signal: SIGINT
vi a 
+ vi a
for i in {1,2,3} 
              do
sush: Unexpected token: 
for i in {1,2,3} 
do
echo a 
done
+ echo a
+ echo a
+ echo a
for i in {1,2,3} 
    do 
sush: Unexpected token: 






sudo vi /usr/share/bash-completion/bash_completion
+ sudo vi /usr/share/bash-completion/bash_completion
exit
+ exit
exit
